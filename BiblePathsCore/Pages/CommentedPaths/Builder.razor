@using System.Timers
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.EntityFrameworkCore
@using BiblePathsCore.Models
@using BiblePathsCore.Models.DB
@inject BiblePathsCoreDbContext DbContext
@inject UserManager<IdentityUser> UserManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager

@page "/commentedpaths/builder/{PathId:int}/{BibleId?}"
@attribute [Authorize]

<h3 class="mb-3">@Path?.Name</h3>

@if (IsLoading)
{
    <div class="text-center my-4">
        <span class="spinner-border" role="status"></span>
        <span> Loading path...</span>
    </div>
}
else if (Path == null)
{
    <div class="alert alert-warning">Path not found.</div>
}
else
{
    <div class="mb-2">
        @if (CanEdit)
        {
            <button class="btn btn-sm btn-outline-primary me-2" type="button" @onclick="() => AddStandardStep(0)">
                Add Standard Step
            </button>
            <button class="btn btn-sm btn-outline-primary me-2" @onclick="@(async () => await AddCommentStep(0))">Add Comment Step</button>
            <button class="btn btn-sm btn-outline-secondary" @onclick="Reload">Refresh</button>
        }
        else if (Path.IsPublished)
        {
            <div class="alert alert-info mt-2">This path is published. Editing is only allowed on un-published paths.</div>
        }
    </div>

    @* Delete Confirmation Modal *@
    @if (ShowDeleteModal)
    {
        <div class="modal fade show" style="display: block;" tabindex="-1" role="dialog">
            <div class="modal-dialog" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Confirm Deletion</h5>
                        <button type="button" class="close" aria-label="Close" @onclick="() => ShowDeleteModal = false">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <p>Are you sure you want to delete this step?</p>
                        <p class="fw-bold">Step @NodeIdToDelete: @DeleteStepLabel</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" @onclick="() => ShowDeleteModal = false">Cancel</button>
                        <button type="button" class="btn btn-danger" @onclick="DeleteConfirmed">Delete</button>
                    </div>
                </div>
            </div>
        </div>
    }

    <div>
        @if (PathNodes?.Any() == true)
        {
            @foreach (var node in PathNodes.OrderBy(n => n.Position))
            {
                <div class="card mb-2" id="PathNode-@node.Id">
                    <div class="card-body">
                        <div class="d-flex justify-content-between">
                            <div>
                                <strong>Step @node.Position</strong>
                                @if (node.Type == (int)StepType.Standard)
                                {
                                    <span class="ms-2">@node.BookName @node.Chapter:@node.StartVerse@(node.EndVerse > node.StartVerse ? " - " + node.EndVerse : "")</span>
                                }
                                else
                                {
                                    <span class="ms-2 text-muted">Commentary</span>
                                }
                            </div>
                            <div>
                                @if (CanEdit)
                                {
                                    <button class="btn btn-sm btn-danger" @onclick="() => PrepareDeleteNode(node.Id, node.Position)">Delete</button>
                                }
                            </div>
                        </div>

                        <div class="mt-2">
                            @if (node.Type == (int)StepType.Standard)
                            {
                                @if (node.Verses != null)
                                {
                                    @foreach (var v in node.Verses)
                                    {
                                        <div><sup>@v.Verse</sup> @v.Text</div>
                                    }
                                }
                            }
                            else
                            {
                                <textarea class="form-control mt-1" rows="5" @oninput="(e) => OnCommentChanged(node, e.Value?.ToString())">@node.Text</textarea>
                                <div class="small text-muted mt-1">Saved: @GetLastSaved(node.Id)</div>
                                @if (_errorMessages.ContainsKey(node.Id))
                                {
                                    <div class="alert alert-danger mt-2">@_errorMessages[node.Id]</div>
                                }
                            }
                        </div>
                    </div>
                </div>
                <div class="mb-2">
                    @if (CanEdit)
                    {
                        <button class="btn btn-sm btn-outline-primary me-2" type="button" @onclick="() => AddStandardStep(node.Position)">
                            Add Standard Step
                        </button>
                        @* <button class="btn btn-sm btn-outline-primary me-2" @onclick="AddCommentStep">Add Comment Step</button> *@
                    }
                </div>
            }
        }
        else
        {
            <div class="text-muted">No steps yet.</div>
        }
    </div>
}

@code {
    [Parameter] public int PathId { get; set; }
    [Parameter] public string BibleId { get; set; }

    private Path Path;
    private Bible Bible;
    private List<PathNode> PathNodes = new();
    private bool IsLoading { get; set; } = true;
    private bool CanEdit { get; set; } = false;
    private bool IsPathOwner { get; set; } = false;
    private bool ShowHelloWorld { get; set; } = false;

    // Add standard step dialog state
    private bool ShowAddStandardDialog { get; set; } = false;
    private int CurrentPosition { get; set; } = 0;
    private string NewStepBookName { get; set; } = string.Empty;
    private int NewStepChapter { get; set; }
    private int NewStepStartVerse { get; set; }
    private int? NewStepEndVerse { get; set; }

    // Delete confirmation modal state
    private bool ShowDeleteModal { get; set; } = false;
    private int? NodeIdToDelete { get; set; }
    private string DeleteStepLabel { get; set; } = "";

    // debounced save timers per node
    private readonly Dictionary<int, Timer> _debounceTimers = new();
    private readonly Dictionary<int, DateTime> _lastSaved = new();
    private Dictionary<int, string> _errorMessages = new();

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("OnInitializedAsync started");
        await LoadPathAsync();
        Console.WriteLine("OnInitializedAsync completed");
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            Console.WriteLine("First render completed");
        }
    }

    private async Task LoadPathAsync()
    {
        IsLoading = true;

        // Load & Confirm Path
        Path = await DbContext.Paths.FindAsync(PathId);
        if (Path == null)
        {
            NavigationManager.NavigateTo($"/error?errorMessage=That's Odd! We were unable to find the requested Commented Path");
            return;
        }

        // We want to use the Owners Bible ID only if BibleId hasn't been provided.
        if (BibleId == null) { BibleId = Path.OwnerBibleId; }
        BibleId = await Path.GetValidBibleIdAsync(DbContext, BibleId);
        Bible = await DbContext.Bibles.FindAsync(BibleId);
        if (Bible == null)
        {
            // there has to be a right way to do the following... this isn't it. 
            return;
        }
        Bible.HydrateBible();

        if (Path == null)
        {
            IsLoading = false;
            return;
        }

        PathNodes = await Path.GetPathNodesAsListAsync(DbContext, BibleId);

        // determine permission: owner or editor (basic owner check)
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated == true)
        {
            var identityUser = await UserManager.GetUserAsync(user);
            if (identityUser != null)
            { 
                // In most cases a simple CanEdit check is OK, however in the delete cases we'll look for isPathOwner
                IsPathOwner = Path.IsPathOwner(identityUser.Email);
                CanEdit = !Path.IsPublished && (IsPathOwner || Path.IsValidPathEditor(identityUser.Email));
            }
        }

        IsLoading = false;
    }

    private void AddStandardStep(int position)
    {
        var targetPage = Uri.EscapeDataString("/Steps/AddStep");
        NavigationManager.NavigateTo($"./Shared/SelectChapter?BibleId={Bible.Id}&PathId={Path.Id}&Position={position}&TargetPage={targetPage}",
                                        forceLoad: true);
    }


    private async Task AddCommentStep(int Position)
    {
        if (!CanEdit) return;

        var newNode = new PathNode
        {
            PathId = Path.Id,
            Type = (int)StepType.Commented,
            Position = Position + 1,
            Text = string.Empty
        };
        DbContext.PathNodes.Add(newNode);
        await DbContext.SaveChangesAsync();
        _ = await Path.RedistributeStepsAsync(DbContext);
        await LoadPathAsync();
    }

    private async Task DeleteNode(int nodeId)
    {
        if (!CanEdit) return;

        var node = await DbContext.PathNodes.FindAsync(nodeId);
        if (node == null) return;

        DbContext.PathNodes.Remove(node);
        await DbContext.SaveChangesAsync();

        // re-sequence positions
        _ = await Path.RedistributeStepsAsync(DbContext);

        await LoadPathAsync();
    }

    private void PrepareDeleteNode(int nodeId, int position)
    {
        NodeIdToDelete = nodeId;
        DeleteStepLabel = $"Step {position}";
        ShowDeleteModal = true;
    }

    private async Task DeleteConfirmed()
    {
        if (NodeIdToDelete.HasValue)
        {
            await DeleteNode(NodeIdToDelete.Value);
            ShowDeleteModal = false;
        }
    }

    // called on every input; implement debounce so we don't spam DB
    private void OnCommentChanged(PathNode node, string newValue)
    {
        if (!CanEdit) return;

        node.Text = newValue ?? string.Empty;

        //clear existing timer for this node
        if (_debounceTimers.TryGetValue(node.Id, out var existing))
        {
            existing.Stop();
            existing.Dispose();
        }

        //create a new timer (500ms)
        var timer = new Timer(500) { AutoReset = false };
        timer.Elapsed += async (_, __) => await SaveNodeTextDebounced(node.Id);
        _debounceTimers[node.Id] = timer;
        timer.Start();
    }

    private async Task SaveNodeTextDebounced(int nodeId)
    {
        // remove timer
        if (_debounceTimers.TryGetValue(nodeId, out var t))
        {
            t.Stop();
            t.Dispose();
            _debounceTimers.Remove(nodeId);
        }

        //obtain node from current PathNodes (to get latest text)
        var node = PathNodes.FirstOrDefault(n => n.Id == nodeId);
        if (node == null) return;

        //attach and save
        try
        {
            DbContext.Attach(node);
            DbContext.Entry(node).Property(n => n.Text).IsModified = true;

            // Before we try to save let's see if there are any offensive words in here
            ContentReview CheckThis = new ContentReview(node.Text);
            if (CheckThis.FindBannedWords() > 0)
            {
                string WordsFound = string.Join(", ", CheckThis.FoundWords);
                string ErrorMessage = "This is awkward, but some of the words above are not aligned with the Bible Paths mission, these include: " + WordsFound;
                _errorMessages[nodeId] = ErrorMessage;
                await DbContext.SaveChangesAsync();
                return;
            }
            if (_errorMessages.ContainsKey(nodeId))
            {
                _errorMessages.Remove(nodeId);
            }

            await DbContext.SaveChangesAsync();

            _lastSaved[nodeId] = DateTime.UtcNow;
            //refresh UI on main thread
            await InvokeAsync(StateHasChanged);
        }
        catch
        {
            //swallow for now; consider logging
        }
    }

    private string GetLastSaved(int nodeId)
    {
        if (_lastSaved.TryGetValue(nodeId, out var dt))
        {
            return dt.ToLocalTime().ToString("g");
        }
        return "never";
    }

    private async Task Reload()
    {
        await LoadPathAsync();
    }

    public void Dispose()
    {
        foreach (var t in _debounceTimers.Values)
        {
            t.Stop();
            t.Dispose();
        }
        _debounceTimers.Clear();
    }
}
