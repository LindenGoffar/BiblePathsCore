@using System.Timers
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.EntityFrameworkCore
@using BiblePathsCore.Models
@using BiblePathsCore.Models.DB
@inject BiblePathsCoreDbContext DbContext
@inject UserManager<IdentityUser> UserManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager

@page "/commentedpaths/builder/{PathId:int}/{BibleId?}"
@attribute [Authorize]
@rendermode @(new InteractiveServerRenderMode(prerender: false))

<h3 class="mb-3">@Path?.Name</h3>

@if (IsLoading)
{
    <div class="text-center my-4">
        <span class="spinner-border" role="status"></span>
        <span> Loading path...</span>
    </div>
}
else if (Path == null)
{
    <div class="alert alert-warning">Odd... This Path was not found.</div>
}
else if (Bible == null)
{
    <div class="alert alert-warning">Odd... We were unable to find this Bible.</div>
}
else
{
    <div class="mb-2">
        @if (CanEdit)
        {
            <button class="btn btn-sm btn-outline-primary me-2" type="button" @onclick="() => AddStandardStep(0)">
                Add Standard Step
            </button>
            <button class="btn btn-sm btn-outline-primary me-2" @onclick="@(async () => await AddCommentStep(0))">Add Comment Step</button>
            <button class="btn btn-sm btn-outline-secondary" @onclick="Reload">Refresh</button>
        }
        else if (Path.IsPublished)
        {
            <div class="alert alert-info mt-2">This path is published. Editing is only allowed on un-published paths.</div>
        }
    </div>

    @* Delete Confirmation Modal *@
    @if (ShowDeleteModal)
    {
        <div class="modal fade show" style="display: block;" tabindex="-1" role="dialog">
            <div class="modal-dialog" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Confirm Deletion</h5>
                        <button type="button" class="close" aria-label="Close" @onclick="() => ShowDeleteModal = false">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <p>Are you sure you want to delete this step?</p>
                        <p class="fw-bold">@DeleteStepLabel</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" @onclick="() => ShowDeleteModal = false">Cancel</button>
                        <button type="button" class="btn btn-danger" @onclick="DeleteConfirmed">Delete</button>
                    </div>
                </div>
            </div>
        </div>
    }

    <div>
        @if (PathNodes?.Any() == true)
        {
            @foreach (var node in PathNodes.OrderBy(n => n.Position))
            {
                <div class="card mb-2" id="PathNode-@node.Id">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
@*                                 <strong>Step @node.Position</strong> *@
                                @if (node.Type == (int)StepType.Standard)
                                {
                                    <span class="ms-2">@node.BookName @node.Chapter:@node.StartVerse@(node.EndVerse > node.StartVerse ? " - " + node.EndVerse : "")</span>
                                }
                                else
                                {@* 
                                    <span class="ms-2 text-muted">Commentary</span> *@
                                }

                                <div class="mt-2">
                                    @if (node.Type == (int)StepType.Standard)
                                    {
                                        @if (node.Verses != null)
                                        {
                                            @foreach (var v in node.Verses)
                                            {
                                                <div><sup>@v.Verse</sup> @v.Text</div>
                                            }
                                        }
                                    }
                                    else
                                    {
                                        <textarea class="form-control mt-1" rows="5" @oninput="(e) => OnCommentChanged(node, e.Value?.ToString())">@node.Text</textarea>
                                        <div class="small text-muted mt-1">Saved: @GetLastSaved(node.Id)</div>
                                        @if (_errorMessages.ContainsKey(node.Id))
                                        {
                                            <div class="alert alert-danger mt-2">@_errorMessages[node.Id]</div>
                                        }
                                    }
                                </div>
                            </div>
                            @if (CanEdit)
                            {
                                <div class="ms-3">
                                    <button class="btn btn-sm btn-danger" @onclick="() => PrepareDeleteNode(node.Id, node.Position, node.SummaryText)">Delete</button>
                                </div>
                            }
                        </div>
                    </div>
                </div>
                <div class="mb-2">
                    @if (CanEdit)
                    {
                        <button class="btn btn-sm btn-outline-primary me-2" type="button" @onclick="() => AddStandardStep(node.Position)">
                            Add Standard Step
                        </button>
                        <button class="btn btn-sm btn-outline-primary me-2" @onclick="@(async () => await AddCommentStep(node.Position))">
                            Add Comment Step
                        </button>
                    }
                </div>
            }
        }
        else
        {
            <div class="text-muted">No steps defined yet.</div>
        }
    </div>
    <div>
        @if(Path.IsPublished)
        {
            <button class="btn btn-outline-primary btn-sm" @onclick="NavigateToUnPublish">UnPublish</button>
        }
        else
        {
            <button class="btn btn-outline-primary btn-sm" @onclick="NavigateToPublish">Publish</button>
        }
        <button class="btn btn-outline-primary btn-sm" @onclick="NavigateToSettings">Settings</button>
    </div>
}

@code {
    [Parameter] public int PathId { get; set; }
    [Parameter] public string BibleId { get; set; }

    private Path Path;
    private Bible Bible;
    private List<PathNode> PathNodes = new();
    private IdentityUser currentUser;
    private bool IsLoading { get; set; } = true;
    private bool CanEdit { get; set; } = false;
    private bool IsPathOwner { get; set; } = false;

    // Add standard step dialog state
    private bool ShowAddStandardDialog { get; set; } = false;

    // Delete confirmation modal state
    private bool ShowDeleteModal { get; set; } = false;
    private int? NodeIdToDelete { get; set; }
    private string DeleteStepLabel { get; set; } = "";

    // debounced save timers per node
    private readonly Dictionary<int, Timer> _debounceTimers = new();
    private readonly Dictionary<int, DateTime> _lastSaved = new();
    private Dictionary<int, string> _errorMessages = new();

    // track last loaded parameters to avoid redundant loads
    private int? _lastPathId;
    private string _lastBibleId;
    private bool _isInitialized = false;

    // Change from property to field
    private bool _isAuthenticated = false;

    protected override async Task OnInitializedAsync()
    {
        if (!_isAuthenticated)
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            _isAuthenticated = authState.User.Identity?.IsAuthenticated == true;
            currentUser = _isAuthenticated ? await UserManager.GetUserAsync(authState.User) : null;
            
            // Initial load if authenticated
            if (_isAuthenticated)
            {
                await LoadPathAsync();
            }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_isAuthenticated && (_lastPathId != PathId || _lastBibleId != BibleId))
        {
            _lastPathId = PathId;
            _lastBibleId = BibleId;
            Console.WriteLine("Loading path...");
            await LoadPathAsync();
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            Console.WriteLine("First render completed");
        }
    }

    private async Task LoadPathAsync()
    {
        string TempBibleId = BibleId;
        IsLoading = true;

        // Load & Confirm Path
        Path = await DbContext.Paths.FindAsync(PathId);

        if (Path == null)
        {
            IsLoading = false;
            return;
        }

        // Go find a valid Bible Id and set it on the Path.
        _ = await Path.SetValidBibleIdAsync(DbContext, BibleId);

        Bible = await DbContext.Bibles.FindAsync(Path.BibleId);
        if (Bible == null)
        {
            IsLoading = false;
            return;
        }
        // Add our Legalese to the Bible object for display purposes
        Bible.HydrateBible();

        // load Path Nodes for this Path, we already have BibleId set correctly on Path
        PathNodes = await Path.GetPathNodesAsListAsync(DbContext, false);

        // determine permission: owner or editor (basic owner check)
        if (currentUser != null)
        {
            // In most cases a simple CanEdit check is OK, however in the delete cases we'll look for isPathOwner
            IsPathOwner = Path.IsPathOwner(currentUser.Email);
            CanEdit = !Path.IsPublished && (IsPathOwner || Path.IsValidPathEditor(currentUser.Email));
        }

        IsLoading = false;
    }

    private void AddStandardStep(int position)
    {
        var targetPage = Uri.EscapeDataString("/Steps/AddStep");
        NavigationManager.NavigateTo($"./Shared/SelectChapter?BibleId={Bible.Id}&PathId={Path.Id}&Position={position}&TargetPage={targetPage}",
                                        forceLoad: true);
    }


    private async Task AddCommentStep(int Position)
    {
        if (!CanEdit) return;

        var newNode = new PathNode
        {
            PathId = Path.Id,
            Type = (int)StepType.Commented,
            Position = Position + 1,
            Text = string.Empty
        };
        DbContext.PathNodes.Add(newNode);
        await DbContext.SaveChangesAsync();
        _ = await Path.RedistributeStepsAsync(DbContext);
        await LoadPathAsync();
    }

    private async Task DeleteNode(int nodeId)
    {
        if (!CanEdit) return;

        var node = await DbContext.PathNodes.FindAsync(nodeId);
        if (node == null) return;

        DbContext.PathNodes.Remove(node);
        await DbContext.SaveChangesAsync();

        // re-sequence positions
        _ = await Path.RedistributeStepsAsync(DbContext);

        await LoadPathAsync();
    }

    private void PrepareDeleteNode(int nodeId, int position, string SummaryText)
    {
        NodeIdToDelete = nodeId;
        DeleteStepLabel = SummaryText;
        ShowDeleteModal = true;
    }

    private async Task DeleteConfirmed()
    {
        if (NodeIdToDelete.HasValue)
        {
            await DeleteNode(NodeIdToDelete.Value);
            ShowDeleteModal = false;
        }
    }

    // called on every input; implement debounce so we don't spam DB
    private void OnCommentChanged(PathNode node, string newValue)
    {
        if (!CanEdit) return;

        node.Text = newValue ?? string.Empty;

        //clear existing timer for this node
        if (_debounceTimers.TryGetValue(node.Id, out var existing))
        {
            existing.Stop();
            existing.Dispose();
        }

        //create a new timer (500ms)
        var timer = new Timer(500) { AutoReset = false };
        timer.Elapsed += async (_, __) => await SaveNodeTextDebounced(node.Id);
        _debounceTimers[node.Id] = timer;
        timer.Start();
    }

    private async Task SaveNodeTextDebounced(int nodeId)
    {
        // remove timer
        if (_debounceTimers.TryGetValue(nodeId, out var t))
        {
            t.Stop();
            t.Dispose();
            _debounceTimers.Remove(nodeId);
        }

        //obtain node from current PathNodes (to get latest text)
        var node = PathNodes.FirstOrDefault(n => n.Id == nodeId);
        if (node == null) return;

        //attach and save
        try
        {
            DbContext.Attach(node);
            DbContext.Entry(node).Property(n => n.Text).IsModified = true;

            // Before we try to save let's see if there are any offensive words in here
            ContentReview CheckThis = new ContentReview(node.Text);
            if (CheckThis.FindBannedWords() > 0)
            {
                string WordsFound = string.Join(", ", CheckThis.FoundWords);
                string ErrorMessage = "This is awkward, but some of the words above are not aligned with the Bible Paths mission, these include: " + WordsFound;
                _errorMessages[nodeId] = ErrorMessage;
                await DbContext.SaveChangesAsync();
                return;
            }
            if (_errorMessages.ContainsKey(nodeId))
            {
                _errorMessages.Remove(nodeId);
            }

            await DbContext.SaveChangesAsync();

            _lastSaved[nodeId] = DateTime.UtcNow;
            //refresh UI on main thread
            await InvokeAsync(StateHasChanged);
        }
        catch
        {
            //swallow for now; consider logging
        }
    }

    private string GetLastSaved(int nodeId)
    {
        if (_lastSaved.TryGetValue(nodeId, out var dt))
        {
            return dt.ToLocalTime().ToString("g");
        }
        return "Yes";
    }

    private async Task Reload()
    {
        await LoadPathAsync();
    }

    private void NavigateToPublish() => NavigationManager.NavigateTo($"/commentedpaths/publish?id={Path.Id}", forceLoad: true);
    private void NavigateToUnPublish() => NavigationManager.NavigateTo($"/commentedpaths/unpublish?id={Path.Id}", forceLoad: true);
    private void NavigateToSettings() => NavigationManager.NavigateTo($"/commentedpaths/edit?id={Path.Id}", forceLoad: true);

    public void Dispose()
    {
        foreach (var t in _debounceTimers.Values)
        {
            t.Stop();
            t.Dispose();
        }
        _debounceTimers.Clear();
    }
}
